---
title: Binary & Computer Basics (Pre-EVM Warmup)
date: 2025-12-06 09:00 +0700
categories: [Blockchain, Basics]
tags: [binary, hex, bitwise, endianness, evm]
author: mxzyy
---

## Binary: the computer's native tongue

Binary is a base-2 number system with only two symbols: `0` and `1`. Each position is a **bit**. Hardware (transistors) is good at detecting two stable voltage levels (low/high), so representing information as 0/1 is cheap, robust, and fast.

A binary number is positional: each bit has weight `2^n` (rightmost is `2^0`, next `2^1`, and so on). Everything in the computer ultimately reduces to patterns of bits: numbers, flags, encodings, hashes, etc.

It's basicly just 0 and 1.

## Hexadecimal: human-friendly binary

Hexadecimal (hex) is base-16 with digits `0–9` and `a–f`. One hex digit equals **4 bits**, so:

- 2 hex digits = 1 byte (8 bits)
- 64 hex digits = 256 bits (1 EVM word)

Hex is not a different internal format; it is just a compact way for humans to read and write binary data. Long binary strings are hard to parse, but hex keeps a perfect 4-bit alignment while staying readable. This is why Ethereum addresses, hashes, and calldata are almost always shown as hex.

## Bits, bytes, widths, and words

- **Bit**: smallest unit, 0 or 1.
- **Byte**: 8 bits; typically the smallest addressable unit in RAM.
- **Bit-width**: number of bits reserved for a value. Unsigned range is `0..(2^n - 1)`. Overflows happen when results exceed that range.
- **Word**: the “natural” size a machine operates on. On many CPUs it is 32 or 64 bits; on the EVM, stack words and storage slots are **256 bits** (32 bytes, 64 hex digits).

Knowing widths and word sizes tells you about ranges, layout, and how tightly you can pack data.

## MSB vs LSB

- **LSB (Least Significant Bit)**: rightmost bit, weight `2^0`; it flips on every increment.
- **MSB (Most Significant Bit)**: leftmost bit, highest weight in the value.

They matter because:

- Signed representations may use the MSB as a sign bit.
- Flags can be assigned to specific bit positions.
- Shifts (`<<`, `>>`) move bits toward or away from the MSB/LSB.

## Endianness (byte order)

Endianness answers: “In what order are bytes of a multi-byte number stored or transmitted?”

Given `0x12345678` (4 bytes: `12 34 56 78`):

- **Big-endian**: `12 34 56 78` (most significant byte first)
- **Little-endian**: `78 56 34 12` (least significant byte first)

CPUs like x86-64 use little-endian; many network protocols and integer encodings use big-endian (“network byte order”).

In EVM land, values are generally treated as **big-endian integers** when seen as hex strings: leftmost hex digit is the most significant; rightmost is least significant.

## Bitwise operators (toolkit)

Bitwise ops act per bit:

- **AND `&`**: keep bits where both inputs are 1 → masking (`value & 0xff`).
- **OR `|`**: set bits to 1 where either input is 1 → setting flags.
- **XOR `^`**: 1 where bits differ → toggling bits, simple checksums.
- **NOT `~`**: flips all bits in the chosen width.
- **Shifts `<<`, `>>`**: move bits left/right, roughly ×2 or ÷2 for unsigned integers, and position fields inside a word.

These are the precise tools to carve, combine, and reposition data inside 256-bit EVM words.

## Connecting this to the EVM

- Calldata, memory, and storage are all just sequences of **bytes**.
- Hex is the human-readable window into those bytes.
- The EVM stack and storage use fixed 256-bit words, which you interpret as big-endian integers or packed fields.

Understanding:

1. Bits/bytes/words and width → you know how big values really are.
2. MSB/LSB and endianness → you read hex correctly and do not misinterpret fields.
3. Bitwise operators → you can extract, pack, and manipulate fields cheaply.

With these basics, EVM opcodes become understandable building blocks acting on bytes and 256-bit words, instead of mysterious low-level runes.
